# -*- coding: utf-8 -*-
"""Trapezio_adaptativo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_vagUAD66XXjIxCFGoFu0DTf9vfgcg0u
"""

import numpy as np
import matplotlib.pyplot as plt

# Função para calcular a integral usando o método do trapézio
def trapezio(func, a, b, N):
    """
    Calcula a integral da função 'func' no intervalo [a, b] usando o método do trapézio com N intervalos.
    Retorna a integral e o erro estimado.
    """
    h = (b - a) / N
    x = np.linspace(a, b, N + 1)
    y = func(x)

    # Cálculo da integral com N intervalos
    extremos = (func(a) + func(b)) / 2.0
    central = np.sum(y[1:N])
    integral_N = (extremos + central) * h

    # Cálculo da integral com 2N intervalos
    xx = np.linspace(a, b, 2 * N + 1)
    yy = func(xx)
    delta = np.sum(yy[1:2 * N:2]) * h / 2
    integral_2N = (extremos + central) * h / 2.0 + delta

    # Estimativa do erro
    erro = abs(integral_N - integral_2N)

    return integral_2N, erro

# Função polinomial de exemplo
def poly(x, a=0, b=1, c=0):
    """
    Função polinomial de segundo grau: a*x^2 + b*x + c
    """
    return a * x**2 + b * x + c

# Processo iterativo para o método do trapézio adaptativo
def trapezio_adaptativo(func, a, b, eps=1e-5, N_min=4):
    """
    Calcula a integral da função 'func' no intervalo [a, b] usando o método do trapézio adaptativo.
    O processo iterativo continua até que o erro seja menor que 'eps'.
    Retorna a integral, o erro e o número de intervalos usados.
    """
    erro = float('inf')
    N = N_min
    integral = 0

    while erro > eps:
        integral, erro = trapezio(func, a, b, N)
        N *= 2  # Dobra o número de intervalos a cada iteração

        # Verificação para evitar loops infinitos
        if N > 1e6:
            print("Atenção: Número máximo de intervalos atingido.")
            break

    return integral, erro, N

# Teste do método do trapézio adaptativo
if __name__ == "__main__":
    # Integral de poly(x) = x de 0 a 1 (valor exato: 0.5)
    integral, erro, N = trapezio_adaptativo(poly, 0, 1)
    print(f"Integral: {integral}, Erro: {erro}, N: {N}")