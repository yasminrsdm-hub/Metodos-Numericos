# -*- coding: utf-8 -*-
"""Método de Adams-Bashforth.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bwaU4tWCiru5R8aNxSN709v6GE7h2tTJ
"""

import numpy as np

def adams_bashforth_moulton(x0, v0, k, dt, T):
    t = np.arange(0, T + dt, dt)
    N = len(t)
    x = np.zeros(N)
    v = np.zeros(N)
    x[0], x[1] = x0, x0 + dt * v0  # Pode precisar de ajuste melhor para x[1]
    v[0], v[1] = v0, v0 - dt * k * x0  # e para v[1] conforme condições iniciais

    for n in range(1, N-1):
        # Predição
        x_p = x[n] + (3/2) * dt * v[n] - (1/2) * dt * v[n-1]
        v_p = v[n] - (3/2) * dt * k * x[n] + (1/2) * dt * k * x[n-1]

        # Correção
        x[n+1] = x[n] + (1/2) * dt * (v_p + v[n])
        v[n+1] = v[n] - (1/2) * dt * k * (x_p + x[n])

    return t, x, v

# Parâmetros
k = 1.0   # constante do sistema
x0 = 0.1  # condição inicial para x
v0 = 0.0  # condição inicial para v
dt = 0.01 # passo de tempo
T = 10    # tempo total de simulação

t, x, v = adams_bashforth_moulton(x0, v0, k, dt, T)

def f(t,u):
return np.sqrt(1+u)

def adams_bash_2(h,Tmax,u1):
dim=np.size(u1)
itmax=np.int(Tmax/h)
u=np.empty((itmax+1,dim))
u[0,:]=u1

#inicaliza com RK2
k1 = f(0,   u[0,:])
k2 = f(h, u[0,:] + k1* h)
u[1,:] = u[0,:] + (k1+k2)* h/2

fn_0=k1
for i in np.arange(0,itmax-1):
t=(i+1)*h
fn_1 = f(t,   u[i+1,:])
u[i+2,:] = u[i+1,:] + h*(-.5*fn_0 + 1.5*fn_1)
fn_0=fn_1
return u





u0=0
h=1e-1
Tmax=1
u=adams_bash_2(h,Tmax,u0)

print(u)